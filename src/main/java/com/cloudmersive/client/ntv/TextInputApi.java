/*
 * validateapi
 * The validation APIs help you validate data. Check if an E-mail address is real. Check if a domain is real. Check up on an IP address, and even where it is located. All this and much more is available in the validation API.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.cloudmersive.client.ntv;

import com.cloudmersive.client.ntv.invoker.ApiClient;
import com.cloudmersive.client.ntv.invoker.ApiException;
import com.cloudmersive.client.ntv.invoker.ApiResponse;
import com.cloudmersive.client.ntv.invoker.Pair;

import com.cloudmersive.client.ntv.model.HtmlSsrfDetectionResult;
import com.cloudmersive.client.ntv.model.SqlInjectionCheckBatchRequest;
import com.cloudmersive.client.ntv.model.SqlInjectionCheckBatchResponse;
import com.cloudmersive.client.ntv.model.SqlInjectionDetectionResult;
import com.cloudmersive.client.ntv.model.XssProtectionBatchRequest;
import com.cloudmersive.client.ntv.model.XssProtectionBatchResponse;
import com.cloudmersive.client.ntv.model.XssProtectionResult;
import com.cloudmersive.client.ntv.model.XxeDetectionBatchRequest;
import com.cloudmersive.client.ntv.model.XxeDetectionBatchResponse;
import com.cloudmersive.client.ntv.model.XxeDetectionResult;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-10-15T17:56:16.404307500-07:00[America/Los_Angeles]")
public class TextInputApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public TextInputApi() {
    this(new ApiClient());
  }

  public TextInputApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Protect html input from Server-side Request Forgery (SSRF) attacks
   * Detects SSRF (Server-side request forgery) attacks and unsafe URL attacks from HTML text input, where attackers can attempt to access unsafe local or network paths in the server environment by injecting them into HTML.
   * @param value User-facing HTML input. (required)
   * @return HtmlSsrfDetectionResult
   * @throws ApiException if fails to make API call
   */
  public HtmlSsrfDetectionResult textInputCheckHtmlSsrf(String value) throws ApiException {
    ApiResponse<HtmlSsrfDetectionResult> localVarResponse = textInputCheckHtmlSsrfWithHttpInfo(value);
    return localVarResponse.getData();
  }

  /**
   * Protect html input from Server-side Request Forgery (SSRF) attacks
   * Detects SSRF (Server-side request forgery) attacks and unsafe URL attacks from HTML text input, where attackers can attempt to access unsafe local or network paths in the server environment by injecting them into HTML.
   * @param value User-facing HTML input. (required)
   * @return ApiResponse&lt;HtmlSsrfDetectionResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<HtmlSsrfDetectionResult> textInputCheckHtmlSsrfWithHttpInfo(String value) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = textInputCheckHtmlSsrfRequestBuilder(value);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("textInputCheckHtmlSsrf", localVarResponse);
        }
        return new ApiResponse<HtmlSsrfDetectionResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<HtmlSsrfDetectionResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder textInputCheckHtmlSsrfRequestBuilder(String value) throws ApiException {
    // verify the required parameter 'value' is set
    if (value == null) {
      throw new ApiException(400, "Missing the required parameter 'value' when calling textInputCheckHtmlSsrf");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/validate/text-input/html/check/ssrf";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofString(value));
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Check text input for SQL Injection (SQLI) attacks
   * Detects SQL Injection (SQLI) attacks from text input.
   * @param value User-facing text input. (required)
   * @param detectionLevel Set to Normal to target a high-security SQL Injection detection level with a very low false positive rate; select High to target a very-high security SQL Injection detection level with higher false positives.  Default is Normal (recommended). (optional)
   * @return SqlInjectionDetectionResult
   * @throws ApiException if fails to make API call
   */
  public SqlInjectionDetectionResult textInputCheckSqlInjection(String value, String detectionLevel) throws ApiException {
    ApiResponse<SqlInjectionDetectionResult> localVarResponse = textInputCheckSqlInjectionWithHttpInfo(value, detectionLevel);
    return localVarResponse.getData();
  }

  /**
   * Check text input for SQL Injection (SQLI) attacks
   * Detects SQL Injection (SQLI) attacks from text input.
   * @param value User-facing text input. (required)
   * @param detectionLevel Set to Normal to target a high-security SQL Injection detection level with a very low false positive rate; select High to target a very-high security SQL Injection detection level with higher false positives.  Default is Normal (recommended). (optional)
   * @return ApiResponse&lt;SqlInjectionDetectionResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SqlInjectionDetectionResult> textInputCheckSqlInjectionWithHttpInfo(String value, String detectionLevel) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = textInputCheckSqlInjectionRequestBuilder(value, detectionLevel);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("textInputCheckSqlInjection", localVarResponse);
        }
        return new ApiResponse<SqlInjectionDetectionResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<SqlInjectionDetectionResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder textInputCheckSqlInjectionRequestBuilder(String value, String detectionLevel) throws ApiException {
    // verify the required parameter 'value' is set
    if (value == null) {
      throw new ApiException(400, "Missing the required parameter 'value' when calling textInputCheckSqlInjection");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/validate/text-input/check/sql-injection";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (detectionLevel != null) {
      localVarRequestBuilder.header("detectionLevel", detectionLevel.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofString(value));
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Check and protect multiple text inputs for SQL Injection (SQLI) attacks in batch
   * Detects SQL Injection (SQLI) attacks from multiple text inputs.  Output preverses order of input items.
   * @param value User-facing text input. (required)
   * @return SqlInjectionCheckBatchResponse
   * @throws ApiException if fails to make API call
   */
  public SqlInjectionCheckBatchResponse textInputCheckSqlInjectionBatch(SqlInjectionCheckBatchRequest value) throws ApiException {
    ApiResponse<SqlInjectionCheckBatchResponse> localVarResponse = textInputCheckSqlInjectionBatchWithHttpInfo(value);
    return localVarResponse.getData();
  }

  /**
   * Check and protect multiple text inputs for SQL Injection (SQLI) attacks in batch
   * Detects SQL Injection (SQLI) attacks from multiple text inputs.  Output preverses order of input items.
   * @param value User-facing text input. (required)
   * @return ApiResponse&lt;SqlInjectionCheckBatchResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SqlInjectionCheckBatchResponse> textInputCheckSqlInjectionBatchWithHttpInfo(SqlInjectionCheckBatchRequest value) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = textInputCheckSqlInjectionBatchRequestBuilder(value);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("textInputCheckSqlInjectionBatch", localVarResponse);
        }
        return new ApiResponse<SqlInjectionCheckBatchResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<SqlInjectionCheckBatchResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder textInputCheckSqlInjectionBatchRequestBuilder(SqlInjectionCheckBatchRequest value) throws ApiException {
    // verify the required parameter 'value' is set
    if (value == null) {
      throw new ApiException(400, "Missing the required parameter 'value' when calling textInputCheckSqlInjectionBatch");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/validate/text-input/check/sql-injection/batch";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(value);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Check text input for Cross-Site-Scripting (XSS) attacks
   * Detects XSS (Cross-Site-Scripting) attacks from text input.
   * @param value User-facing text input. (required)
   * @return XssProtectionResult
   * @throws ApiException if fails to make API call
   */
  public XssProtectionResult textInputCheckXss(String value) throws ApiException {
    ApiResponse<XssProtectionResult> localVarResponse = textInputCheckXssWithHttpInfo(value);
    return localVarResponse.getData();
  }

  /**
   * Check text input for Cross-Site-Scripting (XSS) attacks
   * Detects XSS (Cross-Site-Scripting) attacks from text input.
   * @param value User-facing text input. (required)
   * @return ApiResponse&lt;XssProtectionResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<XssProtectionResult> textInputCheckXssWithHttpInfo(String value) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = textInputCheckXssRequestBuilder(value);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("textInputCheckXss", localVarResponse);
        }
        return new ApiResponse<XssProtectionResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<XssProtectionResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder textInputCheckXssRequestBuilder(String value) throws ApiException {
    // verify the required parameter 'value' is set
    if (value == null) {
      throw new ApiException(400, "Missing the required parameter 'value' when calling textInputCheckXss");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/validate/text-input/check/xss";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofString(value));
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Check and protect multiple text inputs for Cross-Site-Scripting (XSS) attacks in batch
   * Detects XSS (Cross-Site-Scripting) attacks from multiple text inputs.  Output preverses order of input items.
   * @param value User-facing text input. (required)
   * @return XssProtectionBatchResponse
   * @throws ApiException if fails to make API call
   */
  public XssProtectionBatchResponse textInputCheckXssBatch(XssProtectionBatchRequest value) throws ApiException {
    ApiResponse<XssProtectionBatchResponse> localVarResponse = textInputCheckXssBatchWithHttpInfo(value);
    return localVarResponse.getData();
  }

  /**
   * Check and protect multiple text inputs for Cross-Site-Scripting (XSS) attacks in batch
   * Detects XSS (Cross-Site-Scripting) attacks from multiple text inputs.  Output preverses order of input items.
   * @param value User-facing text input. (required)
   * @return ApiResponse&lt;XssProtectionBatchResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<XssProtectionBatchResponse> textInputCheckXssBatchWithHttpInfo(XssProtectionBatchRequest value) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = textInputCheckXssBatchRequestBuilder(value);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("textInputCheckXssBatch", localVarResponse);
        }
        return new ApiResponse<XssProtectionBatchResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<XssProtectionBatchResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder textInputCheckXssBatchRequestBuilder(XssProtectionBatchRequest value) throws ApiException {
    // verify the required parameter 'value' is set
    if (value == null) {
      throw new ApiException(400, "Missing the required parameter 'value' when calling textInputCheckXssBatch");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/validate/text-input/check-and-protect/xss/batch";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(value);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Protect text input from XML External Entity (XXE) attacks
   * Detects XXE (XML External Entity) attacks from text input.
   * @param value User-facing text input. (required)
   * @param allowInternetUrls Optional: Set to true to allow Internet-based dependency URLs for DTDs and other XML External Entitites, set to false to block.  Default is false. (optional)
   * @param knownSafeUrls Optional: Comma separated list of fully-qualified URLs that will automatically be considered safe. (optional)
   * @param knownUnsafeUrls Optional: Comma separated list of fully-qualified URLs that will automatically be considered unsafe. (optional)
   * @return XxeDetectionResult
   * @throws ApiException if fails to make API call
   */
  public XxeDetectionResult textInputCheckXxe(String value, Boolean allowInternetUrls, String knownSafeUrls, String knownUnsafeUrls) throws ApiException {
    ApiResponse<XxeDetectionResult> localVarResponse = textInputCheckXxeWithHttpInfo(value, allowInternetUrls, knownSafeUrls, knownUnsafeUrls);
    return localVarResponse.getData();
  }

  /**
   * Protect text input from XML External Entity (XXE) attacks
   * Detects XXE (XML External Entity) attacks from text input.
   * @param value User-facing text input. (required)
   * @param allowInternetUrls Optional: Set to true to allow Internet-based dependency URLs for DTDs and other XML External Entitites, set to false to block.  Default is false. (optional)
   * @param knownSafeUrls Optional: Comma separated list of fully-qualified URLs that will automatically be considered safe. (optional)
   * @param knownUnsafeUrls Optional: Comma separated list of fully-qualified URLs that will automatically be considered unsafe. (optional)
   * @return ApiResponse&lt;XxeDetectionResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<XxeDetectionResult> textInputCheckXxeWithHttpInfo(String value, Boolean allowInternetUrls, String knownSafeUrls, String knownUnsafeUrls) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = textInputCheckXxeRequestBuilder(value, allowInternetUrls, knownSafeUrls, knownUnsafeUrls);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("textInputCheckXxe", localVarResponse);
        }
        return new ApiResponse<XxeDetectionResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<XxeDetectionResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder textInputCheckXxeRequestBuilder(String value, Boolean allowInternetUrls, String knownSafeUrls, String knownUnsafeUrls) throws ApiException {
    // verify the required parameter 'value' is set
    if (value == null) {
      throw new ApiException(400, "Missing the required parameter 'value' when calling textInputCheckXxe");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/validate/text-input/check/xxe";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (allowInternetUrls != null) {
      localVarRequestBuilder.header("allowInternetUrls", allowInternetUrls.toString());
    }
    if (knownSafeUrls != null) {
      localVarRequestBuilder.header("knownSafeUrls", knownSafeUrls.toString());
    }
    if (knownUnsafeUrls != null) {
      localVarRequestBuilder.header("knownUnsafeUrls", knownUnsafeUrls.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofString(value));
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Protect text input from XML External Entity (XXE) attacks
   * Detects XXE (XML External Entity) attacks from text input.
   * @param request  (required)
   * @return XxeDetectionBatchResponse
   * @throws ApiException if fails to make API call
   */
  public XxeDetectionBatchResponse textInputCheckXxeBatch(XxeDetectionBatchRequest request) throws ApiException {
    ApiResponse<XxeDetectionBatchResponse> localVarResponse = textInputCheckXxeBatchWithHttpInfo(request);
    return localVarResponse.getData();
  }

  /**
   * Protect text input from XML External Entity (XXE) attacks
   * Detects XXE (XML External Entity) attacks from text input.
   * @param request  (required)
   * @return ApiResponse&lt;XxeDetectionBatchResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<XxeDetectionBatchResponse> textInputCheckXxeBatchWithHttpInfo(XxeDetectionBatchRequest request) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = textInputCheckXxeBatchRequestBuilder(request);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("textInputCheckXxeBatch", localVarResponse);
        }
        return new ApiResponse<XxeDetectionBatchResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<XxeDetectionBatchResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder textInputCheckXxeBatchRequestBuilder(XxeDetectionBatchRequest request) throws ApiException {
    // verify the required parameter 'request' is set
    if (request == null) {
      throw new ApiException(400, "Missing the required parameter 'request' when calling textInputCheckXxeBatch");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/validate/text-input/check/xxe/batch";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(request);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Protect text input from Cross-Site-Scripting (XSS) attacks through normalization
   * Detects and removes XSS (Cross-Site-Scripting) attacks from text input through normalization.  Returns the normalized result, as well as information on whether the original input contained an XSS risk.
   * @param value User-facing text input. (required)
   * @return XssProtectionResult
   * @throws ApiException if fails to make API call
   */
  public XssProtectionResult textInputProtectXss(String value) throws ApiException {
    ApiResponse<XssProtectionResult> localVarResponse = textInputProtectXssWithHttpInfo(value);
    return localVarResponse.getData();
  }

  /**
   * Protect text input from Cross-Site-Scripting (XSS) attacks through normalization
   * Detects and removes XSS (Cross-Site-Scripting) attacks from text input through normalization.  Returns the normalized result, as well as information on whether the original input contained an XSS risk.
   * @param value User-facing text input. (required)
   * @return ApiResponse&lt;XssProtectionResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<XssProtectionResult> textInputProtectXssWithHttpInfo(String value) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = textInputProtectXssRequestBuilder(value);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("textInputProtectXss", localVarResponse);
        }
        return new ApiResponse<XssProtectionResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<XssProtectionResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder textInputProtectXssRequestBuilder(String value) throws ApiException {
    // verify the required parameter 'value' is set
    if (value == null) {
      throw new ApiException(400, "Missing the required parameter 'value' when calling textInputProtectXss");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/validate/text-input/protect/xss";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofString(value));
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
