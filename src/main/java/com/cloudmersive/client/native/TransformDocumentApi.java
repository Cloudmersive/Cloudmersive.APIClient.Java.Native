/*
 * convertapi
 * Convert API lets you effortlessly convert file formats and types.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.cloudmersive.client.native;

import com.cloudmersive.client.native.invoker.ApiClient;
import com.cloudmersive.client.native.invoker.ApiException;
import com.cloudmersive.client.native.invoker.ApiResponse;
import com.cloudmersive.client.native.invoker.Pair;

import com.cloudmersive.client.native.model.DocumentTransformEditSession;
import com.cloudmersive.client.native.model.DocxTableTableFillMultiRequest;
import com.cloudmersive.client.native.model.DocxTableTableFillRequest;
import java.io.File;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-10-15T17:26:27.275021200-07:00[America/Los_Angeles]")
public class TransformDocumentApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public TransformDocumentApi() {
    this(new ApiClient());
  }

  public TransformDocumentApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Replace string in Word DOCX document, return result
   * Replace all instances of a string in an Office Word Document (docx)
   * @param matchString String to search for and match against, to be replaced (required)
   * @param replaceString String to replace the matched values with (required)
   * @param inputFileUrl Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API (part of EditDocumentApi) to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public). (optional)
   * @param matchCase Optional: True if the case should be matched, false for case insensitive match. Default is false. (optional)
   * @param inputFile Optional: Input file to perform the operation on. (optional)
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] transformDocumentDocxReplace(String matchString, String replaceString, String inputFileUrl, Boolean matchCase, File inputFile) throws ApiException {
    ApiResponse<byte[]> localVarResponse = transformDocumentDocxReplaceWithHttpInfo(matchString, replaceString, inputFileUrl, matchCase, inputFile);
    return localVarResponse.getData();
  }

  /**
   * Replace string in Word DOCX document, return result
   * Replace all instances of a string in an Office Word Document (docx)
   * @param matchString String to search for and match against, to be replaced (required)
   * @param replaceString String to replace the matched values with (required)
   * @param inputFileUrl Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API (part of EditDocumentApi) to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public). (optional)
   * @param matchCase Optional: True if the case should be matched, false for case insensitive match. Default is false. (optional)
   * @param inputFile Optional: Input file to perform the operation on. (optional)
   * @return ApiResponse&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<byte[]> transformDocumentDocxReplaceWithHttpInfo(String matchString, String replaceString, String inputFileUrl, Boolean matchCase, File inputFile) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = transformDocumentDocxReplaceRequestBuilder(matchString, replaceString, inputFileUrl, matchCase, inputFile);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("transformDocumentDocxReplace", localVarResponse);
        }
        return new ApiResponse<byte[]>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<byte[]>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder transformDocumentDocxReplaceRequestBuilder(String matchString, String replaceString, String inputFileUrl, Boolean matchCase, File inputFile) throws ApiException {
    // verify the required parameter 'matchString' is set
    if (matchString == null) {
      throw new ApiException(400, "Missing the required parameter 'matchString' when calling transformDocumentDocxReplace");
    }
    // verify the required parameter 'replaceString' is set
    if (replaceString == null) {
      throw new ApiException(400, "Missing the required parameter 'replaceString' when calling transformDocumentDocxReplace");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/convert/transform/docx/replace-all";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (inputFileUrl != null) {
      localVarRequestBuilder.header("inputFileUrl", inputFileUrl.toString());
    }
    if (matchString != null) {
      localVarRequestBuilder.header("matchString", matchString.toString());
    }
    if (replaceString != null) {
      localVarRequestBuilder.header("replaceString", replaceString.toString());
    }
    if (matchCase != null) {
      localVarRequestBuilder.header("matchCase", matchCase.toString());
    }
    localVarRequestBuilder.header("Accept", "application/octet-stream");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Replace string in Word DOCX document, return edit session
   * Replace all instances of a string in an Office Word Document (docx).  Returns an edit session URL so that you can chain together multiple edit operations without having to send the entire document contents back and forth multiple times.  Call the Finish Editing API to retrieve the final document once editing is complete.
   * @param matchString String to search for and match against, to be replaced (required)
   * @param replaceString String to replace the matched values with (required)
   * @param inputFileUrl Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API (part of EditDocumentApi) to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public). (optional)
   * @param matchCase Optional: True if the case should be matched, false for case insensitive match. Default is false. (optional)
   * @param inputFile Optional: Input file to perform the operation on. (optional)
   * @return DocumentTransformEditSession
   * @throws ApiException if fails to make API call
   */
  public DocumentTransformEditSession transformDocumentDocxReplaceEditSession(String matchString, String replaceString, String inputFileUrl, Boolean matchCase, File inputFile) throws ApiException {
    ApiResponse<DocumentTransformEditSession> localVarResponse = transformDocumentDocxReplaceEditSessionWithHttpInfo(matchString, replaceString, inputFileUrl, matchCase, inputFile);
    return localVarResponse.getData();
  }

  /**
   * Replace string in Word DOCX document, return edit session
   * Replace all instances of a string in an Office Word Document (docx).  Returns an edit session URL so that you can chain together multiple edit operations without having to send the entire document contents back and forth multiple times.  Call the Finish Editing API to retrieve the final document once editing is complete.
   * @param matchString String to search for and match against, to be replaced (required)
   * @param replaceString String to replace the matched values with (required)
   * @param inputFileUrl Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API (part of EditDocumentApi) to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public). (optional)
   * @param matchCase Optional: True if the case should be matched, false for case insensitive match. Default is false. (optional)
   * @param inputFile Optional: Input file to perform the operation on. (optional)
   * @return ApiResponse&lt;DocumentTransformEditSession&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<DocumentTransformEditSession> transformDocumentDocxReplaceEditSessionWithHttpInfo(String matchString, String replaceString, String inputFileUrl, Boolean matchCase, File inputFile) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = transformDocumentDocxReplaceEditSessionRequestBuilder(matchString, replaceString, inputFileUrl, matchCase, inputFile);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("transformDocumentDocxReplaceEditSession", localVarResponse);
        }
        return new ApiResponse<DocumentTransformEditSession>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<DocumentTransformEditSession>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder transformDocumentDocxReplaceEditSessionRequestBuilder(String matchString, String replaceString, String inputFileUrl, Boolean matchCase, File inputFile) throws ApiException {
    // verify the required parameter 'matchString' is set
    if (matchString == null) {
      throw new ApiException(400, "Missing the required parameter 'matchString' when calling transformDocumentDocxReplaceEditSession");
    }
    // verify the required parameter 'replaceString' is set
    if (replaceString == null) {
      throw new ApiException(400, "Missing the required parameter 'replaceString' when calling transformDocumentDocxReplaceEditSession");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/convert/transform/docx/replace-all/edit-session";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (inputFileUrl != null) {
      localVarRequestBuilder.header("inputFileUrl", inputFileUrl.toString());
    }
    if (matchString != null) {
      localVarRequestBuilder.header("matchString", matchString.toString());
    }
    if (replaceString != null) {
      localVarRequestBuilder.header("replaceString", replaceString.toString());
    }
    if (matchCase != null) {
      localVarRequestBuilder.header("matchCase", matchCase.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Fill in data in a table in a Word DOCX document, return result
   * Replace placeholder rows ina  table in an Office Word Document (docx) using one or more templates
   * @param request  (required)
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] transformDocumentDocxTableFillIn(DocxTableTableFillRequest request) throws ApiException {
    ApiResponse<byte[]> localVarResponse = transformDocumentDocxTableFillInWithHttpInfo(request);
    return localVarResponse.getData();
  }

  /**
   * Fill in data in a table in a Word DOCX document, return result
   * Replace placeholder rows ina  table in an Office Word Document (docx) using one or more templates
   * @param request  (required)
   * @return ApiResponse&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<byte[]> transformDocumentDocxTableFillInWithHttpInfo(DocxTableTableFillRequest request) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = transformDocumentDocxTableFillInRequestBuilder(request);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("transformDocumentDocxTableFillIn", localVarResponse);
        }
        return new ApiResponse<byte[]>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<byte[]>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder transformDocumentDocxTableFillInRequestBuilder(DocxTableTableFillRequest request) throws ApiException {
    // verify the required parameter 'request' is set
    if (request == null) {
      throw new ApiException(400, "Missing the required parameter 'request' when calling transformDocumentDocxTableFillIn");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/convert/transform/docx/table/fill/data";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/octet-stream");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(request);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Fill in data in a table in a Word DOCX document, return edit session
   * Replace placeholder rows ina  table in an Office Word Document (docx) using one or more templates.  Returns an edit session URL so that you can chain together multiple edit operations without having to send the entire document contents back and forth multiple times.  Call the Finish Editing API to retrieve the final document once editing is complete.
   * @param request  (required)
   * @return DocumentTransformEditSession
   * @throws ApiException if fails to make API call
   */
  public DocumentTransformEditSession transformDocumentDocxTableFillInEditSession(DocxTableTableFillRequest request) throws ApiException {
    ApiResponse<DocumentTransformEditSession> localVarResponse = transformDocumentDocxTableFillInEditSessionWithHttpInfo(request);
    return localVarResponse.getData();
  }

  /**
   * Fill in data in a table in a Word DOCX document, return edit session
   * Replace placeholder rows ina  table in an Office Word Document (docx) using one or more templates.  Returns an edit session URL so that you can chain together multiple edit operations without having to send the entire document contents back and forth multiple times.  Call the Finish Editing API to retrieve the final document once editing is complete.
   * @param request  (required)
   * @return ApiResponse&lt;DocumentTransformEditSession&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<DocumentTransformEditSession> transformDocumentDocxTableFillInEditSessionWithHttpInfo(DocxTableTableFillRequest request) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = transformDocumentDocxTableFillInEditSessionRequestBuilder(request);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("transformDocumentDocxTableFillInEditSession", localVarResponse);
        }
        return new ApiResponse<DocumentTransformEditSession>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<DocumentTransformEditSession>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder transformDocumentDocxTableFillInEditSessionRequestBuilder(DocxTableTableFillRequest request) throws ApiException {
    // verify the required parameter 'request' is set
    if (request == null) {
      throw new ApiException(400, "Missing the required parameter 'request' when calling transformDocumentDocxTableFillInEditSession");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/convert/transform/docx/table/fill/data/edit-session";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(request);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Fill in data in multiple tables in a Word DOCX document, return result
   * Replace placeholder rows in multiple tables in an Office Word Document (docx) using one or more templates
   * @param request  (required)
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] transformDocumentDocxTableFillInMulti(DocxTableTableFillMultiRequest request) throws ApiException {
    ApiResponse<byte[]> localVarResponse = transformDocumentDocxTableFillInMultiWithHttpInfo(request);
    return localVarResponse.getData();
  }

  /**
   * Fill in data in multiple tables in a Word DOCX document, return result
   * Replace placeholder rows in multiple tables in an Office Word Document (docx) using one or more templates
   * @param request  (required)
   * @return ApiResponse&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<byte[]> transformDocumentDocxTableFillInMultiWithHttpInfo(DocxTableTableFillMultiRequest request) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = transformDocumentDocxTableFillInMultiRequestBuilder(request);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("transformDocumentDocxTableFillInMulti", localVarResponse);
        }
        return new ApiResponse<byte[]>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<byte[]>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder transformDocumentDocxTableFillInMultiRequestBuilder(DocxTableTableFillMultiRequest request) throws ApiException {
    // verify the required parameter 'request' is set
    if (request == null) {
      throw new ApiException(400, "Missing the required parameter 'request' when calling transformDocumentDocxTableFillInMulti");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/convert/transform/docx/table/fill/data/multi";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, text/json, application/xml, text/xml");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(request);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Replace string in PowerPoint PPTX presentation, return result
   * Replace all instances of a string in an Office PowerPoint Document (pptx)
   * @param matchString String to search for and match against, to be replaced (required)
   * @param replaceString String to replace the matched values with (required)
   * @param inputFileUrl Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API (part of EditDocumentApi) to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public). (optional)
   * @param matchCase Optional: True if the case should be matched, false for case insensitive match. Default is false. (optional)
   * @param inputFile Optional: Input file to perform the operation on. (optional)
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] transformDocumentPptxReplace(String matchString, String replaceString, String inputFileUrl, Boolean matchCase, File inputFile) throws ApiException {
    ApiResponse<byte[]> localVarResponse = transformDocumentPptxReplaceWithHttpInfo(matchString, replaceString, inputFileUrl, matchCase, inputFile);
    return localVarResponse.getData();
  }

  /**
   * Replace string in PowerPoint PPTX presentation, return result
   * Replace all instances of a string in an Office PowerPoint Document (pptx)
   * @param matchString String to search for and match against, to be replaced (required)
   * @param replaceString String to replace the matched values with (required)
   * @param inputFileUrl Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API (part of EditDocumentApi) to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public). (optional)
   * @param matchCase Optional: True if the case should be matched, false for case insensitive match. Default is false. (optional)
   * @param inputFile Optional: Input file to perform the operation on. (optional)
   * @return ApiResponse&lt;byte[]&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<byte[]> transformDocumentPptxReplaceWithHttpInfo(String matchString, String replaceString, String inputFileUrl, Boolean matchCase, File inputFile) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = transformDocumentPptxReplaceRequestBuilder(matchString, replaceString, inputFileUrl, matchCase, inputFile);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("transformDocumentPptxReplace", localVarResponse);
        }
        return new ApiResponse<byte[]>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<byte[]>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder transformDocumentPptxReplaceRequestBuilder(String matchString, String replaceString, String inputFileUrl, Boolean matchCase, File inputFile) throws ApiException {
    // verify the required parameter 'matchString' is set
    if (matchString == null) {
      throw new ApiException(400, "Missing the required parameter 'matchString' when calling transformDocumentPptxReplace");
    }
    // verify the required parameter 'replaceString' is set
    if (replaceString == null) {
      throw new ApiException(400, "Missing the required parameter 'replaceString' when calling transformDocumentPptxReplace");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/convert/transform/pptx/replace-all";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (inputFileUrl != null) {
      localVarRequestBuilder.header("inputFileUrl", inputFileUrl.toString());
    }
    if (matchString != null) {
      localVarRequestBuilder.header("matchString", matchString.toString());
    }
    if (replaceString != null) {
      localVarRequestBuilder.header("replaceString", replaceString.toString());
    }
    if (matchCase != null) {
      localVarRequestBuilder.header("matchCase", matchCase.toString());
    }
    localVarRequestBuilder.header("Accept", "application/octet-stream");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
